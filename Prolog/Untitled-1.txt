TD2 - exo 1 : Factoriel de N 

Integer factoriel = IntStream.rangeClosed(1,n).
                    reduce(1,(a,b) -> a*b);

    - exo 2 : 

    Stream.iterate(new int[]{0, 1},d -> new int[]{d[1],d[0]+d[1]}  )
        .limit(10)
        .map(t -> t[0])
        .forEach(System.out::println);
 

{MEAT=[pork, beef, chicken],
FISH=[prawns, salmon],
OTHER=[french fries, rice, season fruit, pizza]}


Map<String, Set<String>> dishes = menu.stream().
                                   collect(groupingBy(d->d::getType,
                                       mapping(d -> d::getName), toList());
                    


Map<String, Set<String>> types = submenu.stream()
                                .collect(groupingBy(dish;;getType, flatmapping( d->dishes.get(d).getType).stream.toSet());
                                        
                                        ) 



boolean tryAdvance(Consumer<T> consumer){

    if(size == 0){

        return false;
    }
    T element = supplier.get();
    size --;
    consumer.accept(element);
    return true;


Spliterator<T> trySplit(){

    if(currentSize <= L){

        return null;
    }

    half =  size / 2;
    size = size - half;

    return new Splitrator<T>(supplier,size)

}

void execute(Runnable r){

    r.run(); //synchrone
}

(void execute(Runnable r){

    new Thread(r).start(); //asynchrone
}

class sumArray extends Callable<Integer>{

    ExecutorService exec = new ExecutorService.CachedThreadPool();
    this.arr = arr;

    sumArray(int[] array){
        this.arr = array;
    }


    public Integer call(){

        if(arr.length > 1){
            if(arr.length % 2 == 0){

                Future<V> left = exec.submit(newSumArray(arr[]))
                Future<V> right = exec.submit(newSumArray())

            }
        
        }
        else{

            return arr[0] * arr[0];
        }


F(g(f(x) + y) + h(z)).


CompletableFuture<T> c1 =  CompletableFuture.supplyAsync(() -> h(x));
CompletableFuture<T> c2 = CompletableFuture.supplyAsync(() -> f(z)).
                          thenApply((res) -> g(res+y)).
                          thenCombine(c1,(res1,res2) -> F(res1+res2) );

 f(x); if the result is positive, we compute g(f(x)),

 CompletableFuture c1 = CompletableFuture.supplyAsync(() -> f(x))
 .thenApply(res -> res > 0 ? g(res));

        
    
    }
}